var fs = require('fs');
var utils = require('dewm-utils');
var paths = require('dewm-paths');
var xml = require('xml2js');
var oplog = require('mongo-oplog');
var EventEmitter = require("events").EventEmitter;
var dewm = {};

dewm.init = function() {
	var self = this;
	this.evt = new EventEmitter();
	this.depts = ['makeup','makeup','copy','art'];
	this.getDates();
	this.monitorComments();
};

dewm.getDates = function() {
	var self = this;
	var dates = { "dates":[], "strings":[], "stringsWithHyphens":[], "stringsFormatted":[] };
	var mongoFound = [];
	var unordered = [];
	fs.readdir( paths.greenRoot, function (err, files) { 
	    if (!err) {
	        for (var i=0; i<files.length; i++) {
	        	if (files[i].match(/([0-9]){6}$/g) !== null && files[i] != "000000") {
	        		unordered.push(utils.createDateObject(files[i]));
	        	}
	        }
	    } else {
	        error = new Error("You're not connected to the Tablet Green server at the moment.")
	        throw error; 
	    };
	    ordered = unordered.sort(function(a,b){ return a-b; });
	    for (var i=0; i<ordered.length; i++) {
	    	d = utils.formatDate(ordered[i]);
	        dates.dates.push(d[0]);
	        dates.strings.push(d[1]);
	        dates.stringsWithHyphens.push(d[2]);
	        dates.stringsFormatted.push(d[3]);
	        mongoFound.push({ "string":d[1] });
	    }
	    self.checkMissingIssues(mongoFound,dates);
	    self.dates = dates;
	    self.weeks = [];
	    for (var i=0; i<dates.strings.length; i++) { 
		    self.weeks.push({
			    "files":[],
			    "stacks":[],
			    "init":false,
			    "modified":new Date(),
			    "sidecar":paths.sidecar.replace(/<insert_hyphen_date>/g,dates.stringsWithHyphens[i]),
			    "orange":paths.orange.replace(/<insert_hyphen_date>/g,dates.stringsWithHyphens[i]),
			    "green":paths.green.replace(/<insert_date>/g,dates.strings[i])
			}) 
		}
		self.setWeek(dates.strings.length-2);
	});
};

dewm.setWeek = function(week,callback) {
	var self = this;
	self.latest = week;
	if (!self.weeks[week].init) {
		self.weeks[week].init = true;
		self.initWeek(week,callback);	
	}
}

dewm.initWeek = function(week,callback) {
	var self = this,
		mode = typeof mode !== 'undefined' ? mode : "",
		issueDate = self.dates.strings[week],
		issueDateWithHyphens = self.dates.stringsWithHyphens[week],
		issueDateFormatted = self.dates.stringsFormatted[week];
	fs.exists(self.weeks[week].sidecar, function (exists) {
		if (!exists && self.weeks[week].sidecar.indexOf("Archive")>-1) {
			self.setWeek(week-1,callback)
		} else if (!exists) {
			var year = new Date(issueDateFormatted),
				year = year.getFullYear();
			self.weeks[week].sidecar = paths.sidecarArchive.replace(/<insert_year>/g,year).replace(/<insert_hyphen_date>/g,issueDateWithHyphens);
			self.weeks[week].orange = paths.orangeRootArchive.replace(/<insert_year>/g,year).replace(/<insert_hyphen_date>/g,issueDateWithHyphens);
			self.initWeek(week,callback)
		} else {
			self.monitorWeek(week);
			self.getWeek(week,callback);
		}
	});
}

dewm.getWeek = function(week,callback) {
	var self = this;
	fs.readFile(self.weeks[week].sidecar, "utf8", function (err, data) {
		if (data===undefined) {
			self.setWeek(week-1);
		} else {
			xml.parseString(data, function (err, result) {
				if (result == undefined) {
					var response = "The Sidecar XML for "+issueDateFormatted+" is malformed and so it cannot be loaded. Please fix it and try again.";
					self.setWeek(week-1);
				} else {
					var response = "",
						stacks = self.formatStacks(result.sidecar.entry);
					self.weeks[week].files = stacks.files;
					self.weeks[week].stacks = stacks.stacks;
				}
				if(callback) {
					callback(response);
				};
			});
		}
	});
}

dewm.monitorWeek = function(week) {
	var self = this;
	setInterval(function() {
		fs.stat(self.weeks[week].sidecar,function(err, stats){
			var modified = new Date(stats.mtime);
			if (self.weeks[week].modified<modified) {
				self.weeks[week].modified = modified;
				console.log("Update to the sidecar for "+dewm.dates.strings[week]);
				self.getWeek(week);
			}
		});
	},15000);
}

dewm.monitorComments = function(stack) {
	var	self = this,
		listener = oplog(paths.mongo.host+"local", 'dewm.comments').tail();
	listener.on('op', function (data) {
		utils.comments(function(items) {
			self.evt.emit("comment",items);
			if (data.op=="i") {
				utils.notifications.push({alert:"New comment added to the stack by.",url:"http://dewm:3000/views/makeup?stack="+data.o.stack})
			}
		});
	});
}

dewm.checkMissingIssues = function(existing,dates) {
	var self = this,
		mongoDates = [],
		mongoToAdd = [];
	utils.mongo.find("issues",{$or:existing},{},function(err, items){
		for (var i=0; i<items.length; i++) {
			mongoDates.push(items[i]["string"]);
		}
		for (var i=0; i<dates.strings.length; i++) {
			if (mongoDates.indexOf(dates.strings[i])<0) {
				mongoToAdd.push( { 
					"date":dates.dates[i], 
					"string":dates.strings[i], 
					"hyphen":dates.stringsWithHyphens[i], 
					"formatted":dates.stringsFormatted[i]
				} )
			}
		}
		utils.mongo.add("issues",mongoToAdd);
	})
}

dewm.formatStacks = function(stacks) {
	var self = this,
		returnStacks = [],
		stackNumbers = [],
		issue = utils.dateFromStack(stacks[0].folderName[0]);
	for (var i=0; i<stacks.length; i++) {
		var title = stacks[i].articleTitle[0],
			stackDate = utils.dateFromStack(stacks[i].folderName[0]),
			doc = { 
				"title":title.split(" by ")[0].replace("”","").replace("“",""), 
				"stack":stacks[i].folderName[0], 
				"issue":stackDate, 
				"author":title.split(" by ")[1], 
				"kicker":stacks[i].kicker[0], 
				"description":stacks[i].description[0],
				"layout":null,
				"reading":{},
				"copyAssignment":{},
				"artAssignment":{},
				"danville":null,
				"tablet":null,
				"xmlfilename":stacks[i].xmlfilename[0]
			};
		if (stackDate != "undefined" ) {
			stackNumbers.push(stacks[i].folderName[0]);
			returnStacks.push(doc);
		}
	}
	utils.mongo.find("stacks",{issue:issue},{stack:1,_id:0},function(err,original){
		for (var i=0; i<original.length; i++) {
			original[i]=original[i].stack;
		}
		var added=utils.diff(original,stackNumbers)
			deleted=utils.diff(stackNumbers,original);
		if (added.length>0 && deleted.length>0) {
			self.evt.emit("stack",[added,deleted]);
		} else {

		}
	});
	return {stacks:returnStacks,files:stackNumbers};
}

dewm.addStacks = function(stacks) {

}

dewm.initSocket = function (server) {
	var self = this,
		io = require('socket.io')(server);
    io.on('connection', function (socket) {
    	self.evt.on("stack",function(stacks){
    		socket.emit('newStack', stacks);
    	});
    	socket.on('reqStack', function (data) {
    		var actions=data[0],
    			toAdd=data[1];
    		console.log(actions);
    	});
        socket.on('reqComment', function (data) {
        	utils.comments(function(comments){
	    		socket.emit('newComment',comments);
	    	},data.stack,data.dept);
            self.evt.on("comment",function(comments){
	            var returnComments = utils.commentsFilter(comments,data.stack,data.dept)
	            socket.emit('newComment', returnComments);
            })
        });
    });	
}

dewm.init();

module.exports = dewm;